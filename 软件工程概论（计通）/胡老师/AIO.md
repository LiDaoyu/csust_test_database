# 软件工程概论

## 1 - 软件工程概述 (1)

### 软件危机 P1

- 软件危机定义: 计算机软件的开发和维护过程中所遇到的一系列严重问题
- 两个方面
	- 开发: 如何开发软件满足日益增长的需求
	- 维护: 如何维护数量不断膨胀的已有软件
- 七个典型表现
	- 成本进度估计不足
	- 客户需求经常变更或无法满足
	- 软件质量无法保证或不可靠
	- 软件维护无法进行或不可维护
	- 软件文档缺少或不合要求
	- 软件成本在总成本中占比逐年提升
	- 开发效率无法满足进度要求
- 产生原因 (P3): 与软件本身特点有关, 也与软件开发和维护方法不正确有关
- 最大原因: 轻视维护
- 消除途径 (P4): 既要有技术措施, 又要有必要的组织管理措施
  - 对计算机软件有一个正确的认识
  - 采用工程方法、强调团队合作
  - 采用成功经验、方法和技术
  - 使用软件工具

### 软件工程

- 软件定义 P4/5
	- __程序+数据+文档__
	- 一般定义: 软件是程序、数据及相关文档的完整集合
	- IEEE定义: 计算机程序、方法、规则、相关文档资料以及在计算机上运行时必需的数据

- 软件工程定义
	- NATO: 软件工程就是为了 __经济__ 地获得 __可靠__ 且能在实际计算机上有效运行的软件, 而建立、使用和完善的 __工程原理__
	- IEEE: 软件工程是: ①: 把 __系统的__、__规范的__、__可度量的__ 途径应用到软件开发、运行和维护过程；②: 研究①中提到的途径

- 七个特征 P6
	- 关注 __大型__ 程序: 微、小、中、大、甚、极
	- __中心课题__ 是控制 __复杂性__ (编程直接相关)
	- __需求__ 的 __不确定性与易变性__
	- 高效率的 __方法和工具__
	- 和谐有效的 __团队合作__
	- 持续有效地 __支持用户__ 工作
	- 为其他领域和文化背景创造产品 (行业单位 国外外包)

- 七个原理 P7
	- 按 __生命周期__ 严格管理
	- 坚持进行 __阶段评审__
	- 实行严格的 __产品控制__: 需求和基线
	- 采用 __现代__ 程序设计技术: 开发 测试 管理
	- 结果应能清楚地 __审查__
	- 开发小组成员 __少而精__
	- 不断 __改进__ 软件工程实践

- 软件工程方法学定义
	- 软件生命周期全过程中使用的一整套技术方法的集合
	- 主要包括两类: 传统方法学 (结构化方法)、面向对象方法学

- 软件工程方法学三要素
	- 方法: 完成软件开发的技术方法
	- 工具: 自动或半自动的(程序?)支撑环境
	- 过程: 获得高质量软件的工作步骤

- 两种方法学及其各自特点
	- 传统方法学: 常常称为生命周期方法学或结构化范型, 采用结构化分析、设计和实现技术
		- 基本特点
			- 阶段: 生命周期的各个阶段
			- 审查: 每个阶段均要审查
			- 文档: 文档驱动型
		- 地位: 仍然是广泛应用的方法学, 也是软件工程的基础性方法学
	- 面向对象方法学
		- 基本特点
			- 软件构件统一为对象
			- 所有对象抽象成类
			- 类组成类等级
			- 对象之间通过消息联系
	- 两者区别
		- 传统: 自顶向下 划分阶段
		- 面向对象: 抽象归纳 多次迭代

## 1 - 软件工程概述 (2)

### 软件生命周期

- 定义: 从提出软件产品 (项目) 开始, 直到该软件被淘汰的全过程
- 三个时期
	- 软件定义: 确定目标、可行性和需求, 估计成本和进度, 分为三个阶段: 问题定义、可行性研究、需求分析
	- 设计实现: 设计与实现软件, 分为四个阶段: 总体设计、详细设计、编码与单元测试、综合测试
	- 运行维护: 使软件持久满足用户需求, 也称为保障维护
- 八个阶段
	- 问题定义: 明确要解决的问题
	- 可行性研究: 是否可解? 是否值得解?
	- 需求分析: 功能、性能及其他需求
	- 总体设计 (概要设计): 总体上描述系统的功能组成结构
	- 详细设计: 系统详细的规格说明, 包括算法、框图、数据结构等, 可直接进行编码
	- 编码与单元测试: 编程实现, 单元测试
	- 综合测试: 集成、回归与验收测试
	- 运行维护: 改正、适应、完善、预防

### 软件过程

- 定义: 为了获得高质量软件所需要完成的一系列任务的 __框架和步骤__
- 内容: 方法和顺序、交付文档、阶段标志、管理方案
- 方法: 使用生命周期模型简洁地描述软件过程, 又称为 __过程模型__
- 主要模型 (见作业本)
	- 瀑布模型: 文档驱动、线性迭代、一次交付
	- 快速原型: 需求驱动、快速构建、演示产品
	- 增量模型: 构件驱动、逐步构建、分批交付
	- 螺旋模型: 风险驱动
	- 喷泉模型: 面向对象、迭代开发

### 敏捷开发

- 四点宣言
	- __个体和交互__ 胜过过程和工具
	- __可工作软件__ 胜过面面俱到的文档
	- __客户合作__ 胜过合同谈判
	- __响应变化__ 胜过遵循计划
- 敏捷过程: 满足敏捷宣言价值观的软件过程
- 极限编程 (XP): 最主要和最重要的敏捷过程
	- XP 概念: 把好的 __开发实践__ 运用到极致
	- 有效实践: 客户作为开发团队成员、使用用户素材、短交付周期、验收测试、结对编程、测试驱动开发、集体所有、持续集成、可持续的开发速度、开放的工作空间、及时调整计划、简单设计、重构、使用隐喻
	- _结对编程的概念_

## 2 - 可行性研究 (1)

### 可行性研究

- 目的: 最小代价、最短时间内确定问题是否 __可解__、是否 __值得解__
- 实质: 进行一次大大压缩 __简化了的系统分析和设计的过程__, 也就是在较高层次上以较 __抽象__ 的方式进行的系统分析和设计的过程
- _五个方面可行性及理解_
- 八个步骤
	- 复查目标和规模: 确认规模、目标, 清晰描述出限制和约束
	- 分析研究现有系统: 如用户自有、国内外同类
	- 导出数据模型: 如系统流程图、数据流图+数据字典
	- 进一步定义问题: 结合模型, 与用户复查问题
	- 导出评价可行方案: 从五个方面分析与评价可行方案
	- 推荐行动方针: 是否可行? 最佳的可行方案
	- 草拟开发计划: 进度表、成本估计、人员需求、资源需求
	- 撰写与审查文档: 《可行性研究报告》(《可行性分析报告》或《工可报告》) 专家、投资人、用户审查
- _里程碑标志_

### 成本效益分析

- 目的: 开发一个新系统是否值得
- 关键: 估算成本和效益
- 软件开发成本构成
	- 工作: 人力、资源、会议、差旅等
	- 技术: 软件工具、专利与版权
	- 其他: 管理、验收、培训、维护
- 三个成本估算技术: (第 13 章)
	- 代码行: 基于实际经验
	- 任务分解: 阶段工作量比率 (P50, 表 2.2)
	- 模型估计: COCOMO2 模型
- 步骤
	- 软件生命期的年份假设: 保守估计
	- 估算软件开发成本
	- 新旧系统运行费用: 生命期内
	- 新系统产生的经济效益: 软件生命期内的效益
	- 计算成本效益指标: 通过指标反映成本效益
- 成本效益分析指标
	- 货币的时间价值: 比照银行利率, 在软件生命期内可产生的效益折算成现在的静态价值
	- 投资回收期: 软件生命期内累计的经济效益, 按利率折算为现在的静态价值, 等于最初投资所需要的时间
	- 纯收入: 软件生命期内, 累计效益 (折合成现在值) 与投资之差
	- 投资回收率: 生命期内的净利润 (折合成现在值) 除以投入成本

## 2 - 可行性研究 (2)

### 数据流图 (DFD)

- 概念: 描述信息流和数据从输入移动到存储介质或输出过程中所经受的变换的一种图形化技术, 是系统逻辑功能的图形表示 __(只描述 "做什么", 逻辑模型)__
- 软件系统本质: 加工或变换数据
- 约定
	- 为数据流/数据源/数据汇命名
		- 代表整体内容
		- 使用具体名字 (名词)
		- 完整、易理解的命名
	- 为加工/变换/处理命名
		- 代表整体功能
		- 使用动词或动名词 (如产生报表)
		- 完整、易理解的命名
	- __数据流上有箭头, 需要命名__
	- __要有存储__
	- __只有 "数据变换处理"(圆角矩形) 能访问存储__
- 目的
	- 基本目的: 信息交流
		- 用户与分析师交流
		- 开发团队内部交流
	- 拓展目的: 分析设计工具
		- 导出功能模块
		- 导出数据字典与数据结构
		- 面向数据流的设计方法

### 数据字典 (DD)

- 概念: 数据流图中包含的 __所有元素__ 的定义的集合, DFD+DD构成系统的逻辑模型
- 描述对象
	- 数据流
	- 数据流分量 (容易忽略分量)
	- 数据存储
	- __处理 (算法)__
- 描述内容
	- 标识信息: 名字、别名、描述
	- 属性特征: 类型、大小、组成结构 __(数字要有单位)__
	- 使用特点: 范围、频率、来源、条件
	- 控制信息: 调用程序、使用权限
	- 分组信息: 物理位置、从属结构
- 定义方式:
	- 自顶向下分解
	- 表格 (名称 主键 大小 非空 默认 说明)
- 用途
	- 用户与分析员沟通
	- 开发团队内部技术文档
	- 数据库表设计

## 3 - 需求分析

### 需求分析概述

- 基本任务与结束标志
	- 基本任务: 确定 __"系统必须做什么"__
	- 其他任务: 性能 约束 有效性 接口
	- 结束标志: 里程碑
- 综合需求 (八个方面)
	- 功能需求: 需要的功能或服务
	- 非功能需求:
		- 性能: 时间、容量、并发/可伸缩性
		- 可靠性与可用性: 定量、定时
		- 出错和容错处理: 鲁棒性
		- 接口: 用户、软件、通信、IO
		- 约束: 相关标准、安全性、精度、平台
		- 逆向: 不需要的需求
		- 将来: 将来可能的需求

### 获取需求的方法

- 访谈 (直接、间接、正式、非正式)
	- 正式与非正式访谈
	- 直接访谈、调查表、数据流图
	- 情景分析技术
	- 已有系统 (快速原型) 演示
- 面向数据流自顶而下求精
	- 把数据流和数据存储定义到元素级
- 简易规格说明技术
	- 通过访谈等初步确定问题和解决方案
	- 开发者和用户分别提出问题需求
	- 相互或共同审查需求, 合并需求
	- 对每个问题提出一致的需求表
	- 集中与标准化需求, 出具需求分析说明书
- 快速建立软件原型
	- 快速建立起来旨在演示目标系统主要功能的可运行的程序
	- 使用户和开发者在“做什么”上达到一致

### 分析建模与规格说明 P62

- 分析建模
	- 概念: 为理解事物而做出的一种抽象, 是对事物的一种无歧义的书面描述
	- 内容: 由一组图形符号和规则组成
	- 模型:
		- 数据模型: ER 图、范式
		- 功能模型: DFD
		- 行为模型: 状态转换图
- 规格说明书
	- 概念: 用自然语言并结合图表, 完整、准确、具体地描述系统的综合需求和数据需求
	- 方式: 自然语言、形式化方法

### 其他图形工具

- 特点: 直观 生动 容易理解
- 数据层次方框图 (P68 3.5)
	- 是一个多层次的树形结构
	- 顶层矩形表述完整或整个数据
	- 下层矩形表示上一层的数据子项
	- 最底层为实际数据元素 (不能再分割)
	- 注意: 非底层 (顶层与中间层) 的数据一般是抽象的、分组或归纳数据项

### 验证软件需求

- 四个方面 (内容)
	- 一致性: 概念一致无歧义、不能相互矛盾
	- 完整性: 需求完整, 包含用户的全部功能和性能需求, 以及其它的需求 (尽量完整)
		- 待定项必须指出造成待定的场景和解决的时间和方式
		- 参考引用项则必须指出来源及时间
		- 有可能变化的项则指出造成的原因和解决方法
	- 现实性: 可以实现 (技术上)
		- 硬件的容量和性能可以满足需求
		- 软件功能和性能可以满足需求
	- 有效性: 正确的、有效的
		- 不能有超出用户实际或不合理的需求

- 方法
	- 一致性: 人工验证、软件验证 (形式化描述语言)
	- 现实性: 成功案例和经验、仿真或模拟技术
	- 完整有效性: 与用户密切沟通、使用快速原型或已有系统

### 如何理解需求的易变性

- 双方对需求理解不全面不深入
- 项目进展帮助用户和开发者更好地理解需求
- 用户可能更改业务规则
- 没有有效需求管理工具和方法

## 5 - 总体设计

### 总体设计概述

- 基本目的
	- 概要确定系统如何实现 (又称概要设计)
	- 确定最佳方案和最合理的软件结构
- 任务: 设计软件的结构以及模块与单元间的相互关系
- 结果:
	- 文档 (里程碑)
	- 数据库
	- 程序组成结构 (功能层次结构图)
	- 相关数据和文件 (初步测试计划)

### 设计过程

- 两个阶段
	- 系统设计: 确定系统具体 __方案__
	- 结构设计: 确定系统组成 __结构__
- 九个步骤
	- 设想最佳可选方案
	- 选取合理方案
	- 推荐最佳方案
	- 功能分解
	- 设计软件结构
	- 设计数据库
	- 制定测试计划
	- 概要设计说明书
	- 审查和复审
- 五个原理
	- 模块化
		- 模块概念: 一个 __由标识符代表__ 的、__由边界符限定__ 的程序元素序列, 是程序的基本构件
		- 模块化概念: 把程序分解为独立命名且可独立访问的模块 (单元), 每个模块完成一个 (或一组) 子功能, 整体上满足用户指定的功能需求
		- 依据 (P94): $E(P_1+P_2) > E(P_1)+E(P_2)$
		- 通俗表述: 各个击破
		- 目的和结果
			- 软件结构更加清晰
			- 简化设计和容易理解
			- 容易测试和调试
			- 提高可维护性
			- 便于组织和管理
	- 抽象与归纳
		- 概念: 抽取事物的本质而暂时不考虑其细节
		- 实现
			- 自顶向下、逐步求精 (具体化)
			- 模块化 (细化)
			- 由抽象到具体
	- 逐步求精
		- 概念: 为了能集中精力解决主要问题, 而尽量推迟对问题细节的考虑
		- Miller 法则
			- 内容: 一个人在任何时候都只能把注意力集中在 __7±2__ 个知识块上
			- 应用: 九宫格菜单、七秒钟定律
	- 信息隐藏与局部化
		- 隐藏模块的实现细节
		- 变量局部化、错误处理局部化
	- 模块独立性
		- 目的
			- 有效的模块化程序实现容易开发出来
			- 容易阅读和理解、测试和维护
		- 耦合
			- 概念: __不同模块间__ 相互依赖的紧密程度
			- 五种形式
				- 数据耦合: 传参交换数据信息 (使用)
				- 控制耦合: 模块间传递控制信息 (少用)
				- 特征耦合: 传递整个数据结构但只使用部分数据 (少用)
				- 公共环境耦合: 通过公共环境相互作用 (限用)
				- 内容耦合: 访问另一模块数据/非正常转入另一模块/有代码重叠/有多个入口 (不用)
		- 内聚
			- 概念: __模块内各元素间__ 的结合紧密程度
			- 七种形式
				- 偶然内聚: 完成一组关系松散的任务, 各个操作之间没有明显可以看到的关联或逻辑关系 (低内聚)
				- 逻辑内聚: 完成的任务在逻辑上相同或相似, 调用时由传参确定功能 (低内聚, 类似控制耦合)
				- 时间内聚: 任务必须在同一段时间内执行 (中内聚)
				- 过程内聚: 模块内处理元素相关, 且以特定次序执行 (中内聚)
				- 通信内聚: 使用或产生同一输入或输出, 但数据不存在任何关联 (中内聚)
				- 顺序内聚: 模块内处理元素与同一个功能密切相关, 且这些处理必须顺序执行 (高内聚)
				- 功能内聚: 模块内所有处理元素属于一个整体, 完成一个单一的功能 (高内聚, 单模块单功能, 函数设计的指导原则)
- 七个启发规则 (经验规则)
	- 改进软件结构提高模块独立性
	- 模块规模应该适中
	- 深度、宽度、扇出、扇入应适当
		- 深度: 控制层数
		- 宽度: 同一层次模块总数
		- 扇出: 一个模块直接控制的下级模块 (合理: 3~4, 上限: 5~9)
		- 扇入: 直接调用的上级模块个数 (不违背模块独立性下越大越好, 代码重用)
	- 模块的作用域应在控制域之内
		- 模块作用域: 受该模块内一个判定影响的所有模块的集合
		- 模块控制域: 模块本身以及直接或间接从属于它的模块的集合
		- 好设计原则: 受判定影响的模块应该从属于做出判定的那个模块及其直接下属模块 (P101 5.2)
	- 降低模块接口的复杂程度 (接口信息结构简单, 与模块功能一致)
	- 设计单入口单出口模块 (避免内容耦合)
	- 模块功能应该可以预测 (相同输入产生相同输出)

### 提高模块独立性的方法和技术

- 代码分解与合并技术
- 基类与派生类设计技术

### 功能层次结构图

- 通用结构: 三层层次结构图
- 顶层: 系统名称
- 第二层: 抽象 (分组、归纳) 功能、子系统等
	- 按不同子系统分组
	- 按用户权限分组 (管理员和标准用户)
	- 前台与后台
	- 按功能相似性分组
- 第三层: 较明细的功能, 仍然可以是抽象功能 (较大系统)
- 描述的功能合理、符合实际
- 连线表示模块之间调用关系, __没有箭头__

## 6 - 详细设计 (1)

### 详细设计概述

- 目标
	- 确定应该如何 __具体地实现__ 所要求的系统, 不仅在逻辑上 __正确地实现__ 每个模块的功能, 更重要的是设计出的处理过程应该 __简明易懂、便于实现和维护__
- 设计结果
	- 实现 __算法__
	- 程序 __框图__、判定树或伪码等
	- __人机界面__ (UI)
	- 程序 __复杂度估计__
- 设计结果与代码质量的关系: 基本决定最终代码质量
- 关键技术和逻辑基础: 结构程序设计技术

### 结构化程序设计

- 经典: 如果一个程序的代码块仅仅通过 __顺序、选择和循环__ 这 3 种基本控结构进行连接, 并且每个代码块 __只有一个入口和一个出口__, 则称这个程序是结化的
- 扩展: 经典基础上允许使用多分支 (`switch`)
- 修正: 允许使用提前跳出循环 (`break`)

### 过程设计工具

- 程序流程图
	- 基本图元: 方框表示动作, 菱形表示判定, __箭头线表示控制流__, 判定条件的箭头线上 __要标记是/否__
	- 优点: 简明直观
	- 缺点: 注重细节、忽略全局、不易表示数据结构
- 判定树
	- 表示复杂的条件组合和应做的动作之间的关系
	- 结构: 每个分支表示一个判定, 叶子节点表示一条路线多次判定后的最终结果
- 伪代码
	- 过程设计语言 用正文形式表示数据和处理过程
	- 使用自然语言的词汇和结构化语言的语法

## 6 - 详细设计 (2)

### 人机界面设计四类设计问题

- 响应时间
	- 属性: 长度和易变性
	- 要求: 响应时间短、时段差异小、动态提示
	- 程序响应速度并不是越快越好, 如果用户工作速度由人机界面决定, 响应时间过短会迫使用户加快操作节奏, 从而可能会犯错误
	- 即使系统响应时间长, 易变性低也有助于用户稳定工作节奏, 用户往往担心响应时间变慢暗示系统工作异常
- 用户帮助
	- 方式: 集成与附加
	- 具体: 文档、在线提示等
- 出错处理
	- 使用用户可理解的术语描述错误
	- 有助于从错误恢复的建议或方法
	- 指出错误可能导致的负面结果
	- 有听觉或视觉上的提示
	- 应该是中性描述语言
- 命令交互
	- 命令形式: 菜单、按钮或组合、输入指令
	- 学习和记忆难度
	- 命令缩写或定制

### 人机界面设计指南要点

- 一般交互
	- 保持风格与布局等的一致性 (字体、颜色)
	- 提供有意义的反馈信息 (用户理解)
	- 允许操作者犯错误 (但拒绝提交)
	- 破坏操作前要求用户确认 (方式?)
	- 减少操作与操作之间必须记忆的信息量
	- 按功能将动作分类、并以此设计布局
	- 减少输入动作或允许自定义输入
	- 提供输入输入说明与帮助
- 信息显示
	- 高效率使用屏幕
	- 不要用数据淹没用户
	- 使用窗口分割不同类型的信息
	- 使用模拟显示方式表示信息
	- 使用一致标记和可预知的颜色
	- 使用大小写、缩进和文本分组帮助理解
- 数据输入
	- 减少用户输入动作
	- 提供输入帮助
	- 允许用户自定义输入
	- 让用户控制交互流
	- 消除冗余与错误的输入
	- 对错误输入有提示或警告信息
		- 补充: 提供默认选择或按钮

## 6 - 详细设计 (3)

### 程序复杂度定量度量

- 模块质量定性度量
	- 耦合度: 松散
	- 内聚度: 紧密
- 定量度量目的
	- 比较设计或算法的优劣
	- 精确限定模块规模
	- 估算软件工作量和错误量
- 定量方法
	- LOC 代码行计算法
	- McCabe (P137)
		- 根据程序控制流的复杂程度, 定量度量程序的复杂程度, 也称为 __圈复杂度__
		- 流图: 一个 "退化的" 程序流程图, 仅仅描绘程序的控制流程, 不表现数据的具体操作以及分支条件
		- $V(G) = E-N+2$, $E$ 是边数, $N$ 是结点数
		- 用途: $V(G) \leqslant 10$ 是合适的算法
	- Halstead (P139)
		- 根据程序中运算符和操作数的总数来度量程序的复杂度
		- 估算程序长度和错误数

## 7 - 实现 (1)

### 基本概念

- 实现: 编码+测试
- 编码
	- 定义: 是把软件设计结果翻译成用某种程序设计语言书写的程序
	- 另解: 将需求明确到机器可以执行的细节程度
- 测试 (通用的解释, 不是定义)
	- 用人工或自动方法来执行并评价软件产品或其部件的过程
	- 以验证该产品是否满足规定的要求, 或者是识别出期望结果和实际结果之间有无差别

### 选择语言的七个实用标准

- 系统用户要求 (项目特点、运行维护)
- 可以使用的编译程序或运行环境
- 可以得到的软件工具 (免费/正版)
- 工程规模
- 公司技术积累和程序员知识
- 软件可移植性和兼容性
- 软件的应用领域

### 编码风格

- 目的
	- 程序的逻辑层次清晰
	- 易读、易懂、易维护
- 内容
	- 程序内部文档
		- 恰当的标识
			- 有意义的命名: 变量、函数/过程
			- 一致的缩写或简写形式
		- 正确简明的注释
			- 序言性 (模块开始处): 功能、调用、编审者、bug历史
			- 功能性 (源程序内部): 程序段/语句功能、数据状态
		- 程序清单布局: 分块与缩进、阶梯式层次
	- 数据说明
		- 说明的次序应该标准化
		- 变量名说明按字母顺序
		- 复杂数据结构应该说明实现方法和特点
	- 语句构造
		- 原则: 简单、直接
		- 规则
			- 不要为省空间而一行多句
			- 避免复杂的条件测试
			- 避免大量使用循环嵌套和条件嵌套
			- 用括号简化逻辑式和算术式
	- 输入输出
		- 对所有输入数据都进行检验 (验证)
		- 检查输入项重要组合的合法性 (有效)
		- 保持输入格式简单 (简单)
		- 使用数据结束标记, 不要求指定数据的数目
		- 明确交互请求, 详细说明可用选择或边界值
		- 保持输入格式一致 (一致)
		- 设计良好的输出报表: 表格化、图形化
		- 给所有输出的数据加标志
	- 效率
		- 内容: 处理机时间、存储器容量
		- 原则
			- 在需求分析确定
			- 好的设计才能有好的效率
			- 效率与简单性要保持一致
			- 运行效率
			- 存储效率
			- I/O效率
			- 网络效率

## 7 - 实现 (2)

### 软件测试基础

- 定义: 为了发现程序中的错误而执行程序的过程
- 目标 (好的观点)
	- 测试 __是为了发现程序错误__ 而执行程序的过程
	- 好的测试方案是 __可能发现尚未发现错误__ 的方案
	- 成功测试是 __发现了尚未发现的错误__ 的测试
- 错误观点
	- 测试是为了证明程序是正确的
	- 成功测试是没有发现错误的测试
	- 测试本身将改善软件质量

### 软件测试准则

- 所有测试应该追溯到用户需求
	- 需求功能错误是最大的、最严重的错误
- 应该远在测试开始之前就制定出测试计划
	- 需求分析、总体设计阶段就可以做测试计划
- 把 Pareto 原理应用到软件测试中 (80/20 法则)
	- 20% 的模块产生 80% 的错误
- 应该从小规模测试开始, 逐步进行大规模测试
- 穷举测试是不可能的
	- 把程序所有的执行路径检查一遍几乎不可能
	- 测试只能证明程序有错误
- 应该由独立的第三方从事测试工作

### 软件测试方法 (见 7-3)

- 白盒测试 (结构测试)
- 黑盒测试 (功能测试)

### 软件测试步骤

- 模块测试 (单元测试)
	- 将一个完整模块 (类、子程序、小程序等), 从完整的系统中隔离出来进行的测试
	- 目的是保证每个模块作为一个单元能否正确运行
	- 发现的往往是 __详细设计错误__
- 子系统测试 (组件测试)
	- 把经过单元测试的模块 (类、子程序、小程序) 放在一起形成一个子系统来测试
	- 目的是测试模块间的接口
- 系统测试 (集成测试)
	- 把经过测试的子系统装配成完整的系统来测试
	- 目的是发现设计和编码的错误, 还应验证需求说明书中的功能
	- 发现的往往是 __软件设计错误__
- 验收测试 (确认测试)
	- 在用户参与下, 使用实际数据进行的系统测试
	- 目的是验证系统是否确实能够满足用户的需求
	- 发现的往往是 __需求说明书中的错误__

### 单元测试

- 概述
	- 集中测试软件设计的最小单元: 模块
	- 与编码一样, 属于软件过程的同一个阶段
	- 发现模块内部的错误
	- 主要使用 __白盒测试__ 技术
- 测试重点
	- 模块接口: 数据输入/输出的正确性
	- 局部数据结构: 数据说明、初始化、默认值
	- 重要执行通路: 代表性及可能错的执行通路
	- 出错误处理通路: `try...except...finally`
- 边界测试
	- 单元测试的最重要任务
	- 原理: 软件常常在它的边界上失效
	- 举例: 数组的0、n - 1元素; 集合的元素个数
- 代码审查
	- 由审查小组测试源程序代码
	- 特点: 一次审查会可以发现许多错误

### 集成测试

- 定义: 相关模块完成单元测试后, 按系统结构图连接成起来后进行的测试
- 目的: 发现与接口有关的问题
- 测试方法
	- 非渐增式测试 (一步到位): 分别进行单元测试, 再把所有模块按设计要求放在一起的测试
	- 渐增式测试 (主流方法): 把下个要测试的模块同已经测试好的哪些模块结合起来进行测试, 测试完后再把下个应该测试的模块结合进来
- 自顶向下集成测试
	- 过程: 从主控制模块开始, 沿着程序的控制层次向下移动, 逐渐把各个模块结合起来
	- 方式: 深度优先、宽度优先
	- 测试主控制模块: 可能需要编写存根程序 (代替子模块)
	- 实际模块代替存根模块 (广先/宽先)
	- 结合进一个模块就测试一个
	- 必须进行回归测试
- 自底向上集成测试
	- 从最底层模块开始组装和测试
	- 把底层模块组合成实现某个特定子功能族
	- 编写驱动程序 (用于测试的控制程序), 协调输出输入和输出
	- 对由模块组成的子功能族进行测试
	- 去掉驱动程序, 按前面几步把子功能族组合起来形成更大的子功能族 (子系统、系统)
- 比较
- 自顶向下测试优点
	- 不需要测试驱动程序
	- 早期实现程序主要功能
	- 早期发现上层模块的接口错误
- 自顶向下测试缺点
	- 需要存根程序
	- 底层模块错误发现较晚
	- 早期不能充分展开人力
- 回归测试: 重新执行已经做过的测试的某个子集, 保证新引入的变化没有带来非预期的副作用

### 确认测试

- 概念: 也称为验收测试, 它的目标是 __验证软件的有效性__
- 软件有效性: 如果软件功能和性能如同用户所合理期待的, 则该软件就是有效的
- 测试基础: 需求规格说明书
- 测试范围
	- 必须用户积极参与, 或以用户为主
	- 确认测试通常使用 __黑盒测试__ 方法
- 测试结果
	- 功能和性能与用户要求一致 (软件可以接受)
	- 功能和性能与用户要求有差距

### alpha 与 beta 测试
- 如果软件是为许多客户开发的, 一般需要有 alpha 测试与 beta 测试过程
- alpha 测试
	- 软件用户在开发者的场所进行的、且在开发者指导下进行的测试
	- 开发者记录发现的错误和问题
- beta 测试
	- 软件用户在一个或多个客户场所进行的测试, 开发者通常不在 beta 测试现场
	- 用户记录并反馈发现的错误和问题

### 调试

- 概念: 在测试发现错误之后排除错误的过程, 又称为纠错
- 途径
	- 蛮干法: 主要思想是通过计算机找错
	- 回溯法: 从错误地方开始, 人工沿控制流往回追踪分析源程序代码, 直到找到原因为止
	- 原因排除法: 对分查找法、归纳法、演绎法

### 可靠性与可用性

- 可靠性: 是程序在 __给定的时间间隔__ 内, 按照规格说明书的规定成功运行的概率
- 可用性: 是程序在 __给定的时间点__, 按照规格说明书的规定, 成功运行的概率
- 区别
	- 可靠性: 0~t 时间段一直运行正常
	- 可用性: t 时刻运行正常, 可能是一直正常或异常被修复了
- 估计错误数方法
	- 植入错误法
	- 分别测试法

## 7 - 实现 (3)

### 白盒测试概述

- 测试方案: 测试目的+测试数据+预期结果
- 测试用例: 测试数据+预期结果
- 设计目标: 确定一组最可能发现某个错误或某类错误的测试数据
- 测试技术: 各有优点、缺点, 需要多种技术组合
- 测试重点: 程序的控制结构
- 常用技术: 逻辑覆盖、控制结构测试

### 逻辑覆盖

- 概念: 对一系列测试过程的总称, 这组测试过程逐渐进行越来越完整的通路测试
- 测试方法: 有选择地执行程序中的某些代表性的通路, 是对穷举测试的可行的替代方法
语句覆盖
- 选择足够多的测试数据, 使被测试程序中的每个语句 (顺序、判断、循环) 至少执行一次
- 特例: 异常捕获语句
- 覆盖标准 (P162): 语句、判定、条件、判定/条件、条件组合、点、边、路径

### 控制结构测试

- 基本路径测试: McCabe 流图上的测试方法
- 条件测试 (P168): 着重测试程序中的每个条件 (控制结构)
- 循环测试 (P170)
	- 简单循环测试: 至少三次测试
	- 嵌套循环测试
	- 串接循环测试

### 黑盒测试概述

- 黑盒测试 __主要测试功能__, 在测试后期进行
- 不能取代白盒测试, 它们互相补充
- 测试目标
	- 功能是否正确或遗漏
	- 性能是否达到要求
	- 数据结构错误或外部数据库访问错误
	- 初始化和终止错误
	- 界面错误
- 主要方法
	- 等价划分
	- 边界值分析
	- 错误推测

### 等价划分

- 概述
	- 把程序的输入域划分成若干个数据等价类, 每个等价类选取一组代表元素 (一般是边界值) 作为测试用例
	- 理想的测试用例可以发现一类错误
	- 假设: 每个等价类中的一个典型值在测试中的作用, 与这一类所有其他值的作用相同
- 步骤
	- 划分输入数据域为若干有效等价类和若干无效等价类
	- 每个类选取一组代表性的测试用例
- 划分方式
	- 有效输入的等价类
	- 无效输入的等价类
	- 合法输出的等价类
	- 非法输出的等价类

### 边界值分析

- 测试经验: 边界情况程序最容易发生错误
- 常见情形: 下标、数据结构、循环、纯数值等的边界附近
- 等价类
	- 确定数据边界, 例如: 选取数据等于、刚刚小于、刚刚大于边界值
	- 有效等价类: 等于、边界范围内
	- 无效等价类: 刚刚小于和/或刚刚大于 (超出范围)

### 错误推测

- 测试经验: 靠测试人员的知觉、经验推测程序中可能的错误
	- 例如网络程序测试中的断网、连网、服务器忙等
- 测试步骤: 列出程序中可能有的错误和容易发生错误的情况, 有选择地制作测试方案

## 8 - 维护

### 软件维护概述

- 定义: 软件已经交付使用之后, 为了改正错误或满足新的需要而修改软件的过程
- 任务: 保证软件持久地满足用户需求、持续支持用户工作
- 四类维护活动
	- 改正性维护: 诊断和改正错误
	- 适应性维护: 适应软件硬件运行与开发环境
	- 完善性维护: 修改已有功能、增加新功能
	- 预防性维护: 为未来的需求

### 软件维护的特点

- 特点:
	- 结构化与非结构化维护差别巨大
	- 维护代价高昂
	- 维护问题很多

- 非结构化维护
	- 软件配置的唯一成分是程序代码, 无程序内部文档
	- 这种维护代价大, 质量无法保证
- 结构化维护
	- 存在完整的软件配置(代码、内部文档、测试用例等), 维护工作可以从设计文档开始
	- 维护代价低、质量有保证

- 维护代价模型
	- $M = P + K \times \exp (c - d)$
	- $M$: 总工作量 / $P$: 生产工作量 / $K$: 常数 / $c$: 复杂度 / $d$: 熟悉度

- 维护的五个问题
	- 起因: 软件定义和软件开发方法的缺陷
		- 理解别人的代码困难程度与软件配置成强反比
		- 需要维护的软件没有合格的文档或资料不足
		- 维护人员往往不是开发者
		- 早期软件在设计时没有考虑将来的修改问题
		- 维护工作不是一项吸引人的工作

### 软件维护的过程

- 维护组织: 非正式地委托责任
- 维护报告及内容
	- 软件问题报告: 要求维护的用户填写
	- 改正性维护请求: 错误环境 (输入数据、输出数据、错误信息)
	- 适应/完善性维护请求: 维护要求
	- 软件修改报告
		- 维护请求的性质
		- 满足维护要求的工作量估算
		- 维护要求的优先次序
		- 与修改有关的事后数据
- 维护事件与记录
- 评价维护活动
	- 每次程序运行平均失效的次数
	- 用于每一类维护活动的总人时数
	- 平均每个程序、每种语言、每种维护类型所做的程序变动数
	- 维护过程中增加或删除一个源语句 (函数) 平均花费的人时数
	- 维护每种语言平均花费的人时数
	- 一张维护要求表的平均周转时间
	- 不同维护类型所占的比例

### 软件的可维护性

- 概念: 维护人员理解、改正、改动或改进软件的难易程度
- 五个因素
	- 可理解性: 理解软件的结构、功能、接口和内部处理过程的难易程序
	- 可测试性: 诊断和测试的难易程度, __度量方法: 程序复杂度__ (P195)
	- 可修改性: 软件容易修改的程度
	- 可移植性: 从一种计算环境转移到另一种计算环境的难易程度
	- 可重用性: 不做修改或稍加改动就在不同的环境中可以多次重复使用
- 维护文档 (P195作用的说明)
	- 影响软件可维护性的决定因素
	- 基本要求
		- 如何使用系统
		- 怎样安装和管理系统
		- 系统的需求和设计方案
		- 系统的实现和测试
	- 分类
		- 用户文档: 安装手册、操作指南、参考手册、使用手册
		- 系统文档: 问题定义、可行性研究报告 (工可报告)、需求规格说明书、总体设计说明书、详细设计说明书、测试验收计划
- 可维护性复审
	- 必须在开发阶段保证软件具有可维护性五个因素
	- 软件工程过程每个阶段都应考虑并努力提高软件可维护性
	- 每个阶段结束前着重对可维护性进行复审
		- 需求阶段: 适应性、可移植性、预防性
		- 设计阶段: 容易修改、模块化
		- 编码阶段: 可理解性、可读性、可重用性
		- 测试阶段: 完整性、一致性、可理解性

### 软件再工程

- 定义: 为了以新形式重构已存在软件系统而实施的检测、分析、更替; 以及随后构建新系统的工程活动
- 目的: 对该软件重新实现以期增强功能、提高性能、降低实现难度; 达到维持软件现功能并为今后新功能的加入做好准备
- 对象: 当前使用中的系统; 或者一些遗留系统 (缺乏良好设计结构和编码风格; 缺少文档)
- 六个步骤
	- 库存目录分析: 系统基本信息、过去报告错误、未来预期修改
	- 文档重构 (设计重构): 保持现状、更新文档、重构全部文档
	- 逆向工程
		- 分析程序以便在比源代码更高的抽象层次上创建出程序的某种表示的过程, 也是一个恢复设计的过程
		- 需要抽取如下设计信息: 体系结构、数据结构、处理过程
	- 代码重构: 在分析源代码的基础上, 重构模块中的代码
	- 数据重构
		- 全范围的低层次再工程
		- 分析与分解当前数据体系结构
		- 重定义数据模型
	- 正向工程:
		- 从现有程序中恢复设计信息, 而且使用该信息去改变或重构现有系统
		- 也称为革新或改造

### 重构

- 概念: 对软件内部的调整, 目的是在不改变软件可观察行为的前提下, 提高其可理解性, 降低其修改成本
- 原因
	- 改进软件设计
	- 使软件更容易理解
	- 帮助找到bug
	- 提高编程速度

## 13 - 软件项目管理

### 管理的概念

- 管理: 就是通过计划、组织和控制等一系列活动, 合理地配置和使用各种资源, 以达到既定目标的过程
- 软件项目管理: 先于任何技术活动之前, 并且贯穿于软件的整个生命周期之中
- 主要工作
	- 估算软件规模和工作量
	- 制定进度计划
	- 人员与配置管理
	- 质量保证

### 软件规模估算

- 代码行技术 (P305)
	- 概念: 根据以往开发过的类似产品或模块的经验, 以及相关的历史数据, 估计一个功能所需要的源程序行数
	- 计算方法: 由多名有经验的软件工程师分别做出估计, 然后 __加权计算__
	- $\text{LOC} = (a + 4 \times m + b) \div 6$
	- $a$: 最小规模 / $b$: 最大规模 / $m$: 最有可能的规模
	- 单位: KLOC (千行代码)
	- 优点
		- 是软件项目的生成品
		- 容易计算, 且有一些计算模型
	- 缺点
		- LOC 代表整个软件项目的规模不合理
		- 同一个软件不同语言的 LOC 差异较大
		- 不适用于非过程语言 (如 SQL)
- 功能点技术 (P306)
	- 概念: 依据对软件信息域特性和软件复杂性评估结果估算软件的规模, 度量结果是功能点 (FP)
	- 信息域五个特性
		- 输入项数 (INP)
		- 输出项数 (OUT)
		- 查询数 (INQ)
		- 主文件数 (MAF)
		- 外部接口数 (INF)
	- 大小值比较: 输入、查询最小, 文件最大
	- 估算步骤
		- 计算未调整的功能点数 $\text{UFP}$
		- 计算技术复杂性因子 $\text{TCF}$
			- 14 个技术因子 (P307)
	- 计算单位: 功能点数 $\text{FP} = \text{UFP} \times \text{TCF}$
	- 优点
		- 与编程语言无关, 既适合于传统的语言, 也可用于非过程语言
		- 项目开发初期就可能得到的数据
	- 缺点
		- 信息域特性及复杂度存在较大主观因素
		- FP 没有直接的物理含义, 只能对比估算

### 工作量估算

- 与软件规模的关系: 是软件规模的函数
- 计算单位: 人月 (PM)
- 估算模型:
	- 静态单变量: 工作量只是软件规模 (LOC/FP) 的函数
	- 动态多变量: 把工作量看成软件规模和开发时间的函数
	- COCOMO2 (三层估算模型, P309)
		- 应用系统组成模型: 用于估算构建原型的工作量
		- 早期设计模型: 用于体系结构设计阶段
		- 后体系结构模型: 软件开发阶段

### 进度计划 (P313)

- 路径、关键路径、任务集合 (P318)
- 项目管理目标: 定义全部项目任务, 识别出关键任务, 跟踪关键任务的进展状况
- 项目进度计划: 通过把工作量分配给特定的软件工程任务并规定完成各任务的起止日期, 从而将估算出的项目工作量分布于计划好的项目持续期内
- 开发时间与人数不是简单的反比关系
- 开发时间最多可以减少到正常的 75%
- 如果要求一个系统的开发时间过短, 开发成功概率几乎为零
- Brooks 规律: 向一个已经延期的项目增加人力只会使它更加延期
- 通信线路: 项目组成员之间的相互联系的途径数
- 通信线路与软件生产率的关系 P313

### 人员组织 (P320)
- 民主制程序组
	- 特点
		- 小组成员完全平等
		- 通过协商作出技术决策
		- 规模一般较小 (2~8人)
		- 通常采用非正式的组织方式
	- 优点: 组员态度积极、凝聚力高、利于攻克难关
	- 缺点: 协调成本高、任务分工可能不均匀
- 主程序员组
	- 背景
		- 组成员多数缺乏经验
		- 有大量的事物性工作
		- 通信渠道较多，降低程序员的生产率
	- 组成: 主程序员、程序员、后备程序员、秘书
- 现代程序员组
	- 背景
		- 主程序员有过多的行政性事物
		- 小组成员积极性与主动性不与民主制
	- 组成: 技术负责、行政负责、程序员

### 质量保证

- 软件质量: 软件与明确地叙述的 __功能和性能需求__、文档中明确的 __开发标准__ 以及任何专业开发的软件产品都应该具有的 __隐含特征相一致__ 的程度
- 要点:
	- 需求是度量基础
	- 遵循指定的开发标准
	- 满足软件行业隐含的标准或需求
- 13 个质量因素及其内涵 (P325: 表 13.7)
- 软件质量保证措施 (SQA)
	- 基于非执行的测试 (复审或评审)
	- 基于执行的测试 (软件测试)
	- 程序正确性证明

### 软件配置管理

- 软件配置: 软件过程中产生的全部信息, 包括
	- 计算机程序 (源码、可执行程序)
	- 描述计算机程序的文档 (用户、开发者)
	- 数据与文件 (程序内的、程序外的)
- 软件配置活动目的: 在软件的整个生命期内管理变化
- 软件配置管理目标: 使变化更正确且更容易被适应, 在必须变化时减少需要花费的工作量和成本
- 基线: 通过了 __正式复审__ 的软件配置项
- 五个步骤
	- 标识软件配置项: 名字、描述、资源表、版本
	- 版本控制: 用户可以选择适当的版本来指定软件的配置
	- 变化控制
		- 访问控制: 配置项的访问权限
		- 同步控制: 并行修改时不会相互覆盖
	- 配置审计: 正式的技术复审、软件配置审计
	- 状态报告: 报告软件配置的变化、状态及影响等
